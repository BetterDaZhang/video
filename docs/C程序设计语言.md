## C程序设计语言

### 1. 导言

EOF 文件结束符

%d %.1f %6.1f

getchar()

函数中的每个局部变量只在函数被调用时存在，在函数执行完毕退出时消失。 =>自动变量。

外部变量  extern

### 2. 类型、运算符和表达式

\ooo 代表1～3个八进制数字。\013

\xhh 代表一个或多个十六进制数据 \xb

\a响铃符   \b回退符 \f换页符   \n换行符.  \r 回车符   \t 横向制表符   \v 纵向制表符

\\\反斜杠    \?问号  \'单引号\" 双引号 \ooo 八进制数 \xhh 十六进制数

字符常量'\0'表示值为 0 的字符，也就是空字符(null)。我们通常用'\0'的形式代替 0， 以强调某些表达式的字符属性，但其数字值为 0。

字符串的内部表示使用一个空字符'\0'作为 串的结尾，因此。存储字符串的物理存储单元数比括在双引号中的字符数多一个。

我们应该搞清楚字符常量与仅包含一个字符的字符串之间的区别:'x'与"x"是不同的。 前者是一个整数，其值是字母 x 在机器字符集中对应的数值(内部表示值);后者是一个包含 一个字符(即字母 x)以及一个结束符'\0'的字符数组。

但是，在某些场合下 goto 语句还是用得着的。最常见的用法是终止程序在某些深度嵌套 的结构中的处理过程，例如一次跳出两层或多层循环。这种情况下使用 break 语句是不能达 到目的的，它只能从最内层循环退出到上一级的循环。下面是使用 goto 语句的一个例子:

```c
for ( ... )
for ( ... ) {
  ...
  if (disaster)
    goto error;
} ...

error:
/* clean up the mess */

```

由于 C 语言不允许在一个函数中定义其它函数， 因此函数本身是“外部的”。

外部变量的用途还表现在它们与内部变量相比具有更大的作用域和更长的生存期。

而外部变量是永久存在的，它们的值在一次函数调用到下一次函数调用之间保持不变。 因此，如果两个函数必须共享某些数据，而这两个函数互不调用对方，这种情况下最方便的 方式便是把这些共享数据定义为外部变量，而不是作为函数参数传递。

> 下面我们通过一个更复杂的例子来说明这一点。我们的目标是编写一个具有加(+)、减 (-)、乘(*)、除(/)四则运算功能的计算器程序。为了更容易实现，我们在计算器中使用 **逆波兰表示法**代替普通的中辍表示法(逆波兰表示法用在某些袖珍计算器中，Forth 与 Postscript 等语言也使用了逆波兰表示法)。
> 在逆波兰表示法中，所有运算符都跟在操作数的后面。比如，下列中缀表达式:
> (1 – 2) * (4 + 5)
> 采用逆波兰表示法表示为:
> 12-45+*
> 逆波兰表示法中不需要圆括号，只要知道每个运算符需要几个操作数就不会引起歧义。
>
> 计算器程序的实现很简单。每个操作数都被依次压入到栈中;当一个运算符到达时，从 栈中弹出相应数目的操作数(对二元运算符来说是两个操作数)，把该运算符作用于弹出的操 作数，并把运算结果再压入到栈中。例如，对上面的逆波兰表达式来说，首先把 1 和 2 压入 到栈中，再用两者之差-1 取代它们;然后，将 4 和 5 压入到栈中，再用两者之和 9 取代它们。 最后，从栈中取出栈顶的-1 和 9，并把它们的积-9 压入到栈顶。到达输入行的末尾时，把栈顶 的值弹出并打印。
> 这样，该程序的结构就构成一个循环，每次循环对一个运算符及相应的操作数执行一次 操作:
>     while (下一个运算符或操作数不是文件结束指示符) if (是数)
>     将该数压入到栈中 else if (是运算符)
>           弹出所需数目的操作数
>           执行运算
>           将结果压入到栈中
>     else if (是换行符) 弹出并打印栈顶的值
>     else
>     出错
>
> 栈的压入与弹出操作比较简单，但是，如果把错误检测与恢复操作都加进来，该程序就 显得很长了，最好把它们设计成独立的函数，而不要把它们作为程序中重复的代码段使用。 另外还需要一个单独的函数来取下一个输入运算符或操作数。
>
> 到目前为止，我们还没有讨论设计中的一个重要问题:把栈放在哪儿?也就是说，哪些 例程可以直接访问它?一种可能是把它放在主函数 main 中，把栈及其当前位置作为参数传递 给对它执行压入或弹出操作的函数。但是，main 函数不需要了解控制栈的变量信息，它只进 行压入与弹出操作。因此，可以把栈及相关信息放在外部变量中，并只供 push 与 pop 函数 访问，而不能被 main 函数访问。
>       #include... /* 一些包含头文件 */ #define... /* 一些 define 定义 */
>       main 使用的函数声明 main() { ... }
>       push 与 pop 所使用的外部变量 void push( double f) { ... } double pop(void) { ... }
>       int getop(char s[]) { ... }
>       被 getop 调用的函数
>
> 我们在后面部分将讨论如何把该程序分割成两个或多个源文件。



```


```



```
中序转后序

```

### 5. 指针和数组

指针是一种保存变量地址的变量。

指针和goto语句一样，会导致程序难以理解。如果使用者粗心，指针很容易就指向了错误的地方。但是，如果谨慎地使用指针，便可以利用它写出简单、清晰的程序。

#### 5.1 内存是如何组织的

通常的机器都有一系列连续编号或编址的存储单元，这些存储单元可以单个进行操纵，也可以以连续成组的方式操纵。通常情况下，机器的一个字节可以存放一个char类型的数据，两个相邻的字节存储单元可存储一个short类型的数据，而四个相邻的字节存储单元可存储一个long类型的数据。指针是能够存放一个地址的一组存储单元（通常是两个或4个字节）。因此，如果c的类型是char，并且p是指向c的指针，则可以用下图表示它们之间的关系：

![](http://p1yseh5av.bkt.clouddn.com/18-1-15/54070792.jpg)

一元运算符&可用于取一个对象的地址

```c
p = &c;
```

地址运算符&只能应用于内存中的对象，即变量与数组元素。它不能作用域表达式、常量或register类型的变量。

一元运算符*是间接寻址或间接引用运算符。当它作用于指针时，将访问指针所指向的对象。

```c
int x = 1, y = 2, z[10];
int *ip; /* ip is a pointer to int */
 
ip=&x; /*ip now points to x*/
y=*ip; /*y is now 1*/
*ip=0; /*x is now 0*/
ip = &z[0];/* ip now points to z[0] */
```

指针只能指向某种特定类型的对象，也就是说，每个指针都必须指向某种特定的数据类型。

(一个例外情况是指向 void 类型的指针可以存放指向任何类型的指针， 但它不能间接引用其自身)

一元运算符*和&的优先级比算术运算符的优先级高.

由于 C 语言是以传值的方式将参数值传递给被调用函数。

```c
那么，如何实现我们的目标呢，可以使主调程序将指向所要交换的变量的指针传递给被
调用函数，即:
swap(&a, &b);
由于一元运算符&用来取变量的地址，这样&a 就是一个指向变量 a 的指针。swap 函数的所有
参数都声明为指针，并且通过这些指针来间接访问它们指向的操作数。
void swap(int *px, int *py) /* interchange *px and *py */ {
int temp;
temp = *px; *px = *py; *py = temp;
}
```

指针参数使得被调用函数能够访问和修改主调函数中对象的值。

#### 5.2 指针与数组

在C语言中，指针和数组之间的关系十分密切。

通过数组下标所能完成的任何操作都可以通过指针来实现。

一般来说，用指针编写的程序比用数组下标编写的程序执行速度快，但另一方面，用指针实现的程序理解起来稍微困难一些。

int a[10];
定义了一个长度为 10 的数组 a。换句话说，它定义了一个由 10 个对象组成的集合，这 10 个

对象存储在相邻的内存区域中，名字分别为 a[0]、a[1]、...、a[9]

![](http://p1yseh5av.bkt.clouddn.com/18-1-15/68335842.jpg)

a[i]表示该数组的第 i 个元素。如果 pa 的声明为int *pa;

则说明它是一个指向整型对象的指针，那么，赋值语句

pa = &a[0];
则可以将指针 pa 指向数组 a 的第 0 个元素，也就是说，pa 的值为数组元素 a[0]的地址。

![](http://p1yseh5av.bkt.clouddn.com/18-1-15/94890349.jpg)

这样，赋值语句
x = *pa;
将把数组元素 a[0]中的内容复制到变量 x 中。

如果 pa 指向数组中的某个特定元素，那么，根据指针运算的定义，pa+1 将指向下一个 元素，pa+i 将指向 pa 所指向数组元素之后的第 i 个元素，而 pa-i 将指向 pa 所指向数组 元素之前的第 i 个元素。因此，如果指针 pa 指向 a[0]，那么*(pa+1)引用的是数组元素 a[1]的内容，pa+i 是数组元素 a[i]的地址，*(pa+i)引用的是数组元素 a[i]的内容

![](http://p1yseh5av.bkt.clouddn.com/18-1-15/59986824.jpg)

无论数组 a 中元素的类型或数组长度是什么，上面的结论都成立。“指针加 1”就意味着，pa+1 指向 pa 所指向的对象的下一个对象。相应地，pa+i 指向 pa 所指向的对象之后的第 i个对象。

下标和指针运算之间具有密切的对应关系。根据定义，数组类型的变量或表达式的值是该数组第 0 个元素的地址。执行赋值语句

pa = &a[0];
后，pa 和 a 具有相同的值。因为数组名所代表的就是该数组最开始的一个元素的地址，所以，

赋值语句 pa=&a[0]

也可以写成下列形式:

pa = a;

对数组元素 a[i]的引用也可以写成*(a+i)这种形式。

计算数组元素 a[i]的值时，C 语言实际上先将其转换为\*(a+i)的形 式，然后再进行求值，因此在程序中这两种形式是等价的。如果对这两种等价的表示形式分 别施加地址运算符&，便可以得出这样的结论:&a[i]和 a+i 的含义也是相同的。a+i 是 a之后第 i 个元素的地址。相应地，如果 pa 是个指针，那么，在表达式中也可以在它的后面加 下标。pa[i]与*(pa+i)是等价的。简而言之，一个通过数组和下标实现的表达式可等价地 通过指针和偏移量实现。

但是，我们必须记住，数组名和指针之间有一个不同之处，指针是一个变量，因此，在 C 语言中，语句 pa=a 和 pa++都是合法的。但数组名不是变量，因此，类似于 a=pa 和 a++形 式的语句是非法的。

当把数组名传递给一个函数时，实际上传递的是该数组第一个元索的地址。

```
在函数定义中，形式参数 char s[];和char *s; 是等价的。
```

我们通常更习惯于使用后一种形式，因为它比前者更直观地表明了该参数是一个 指针。

引用数组边界之外的对象是非法的。

#### 5.3  地址算术运算

如果 p 是一个指向数组中某个元素的指针，那么 p++将对 p 进行自增运算并指向下一个 元素，而 p+=i 将对 p 进行加 i 的增量运算，使其指向指针 p 当前所指向的元素之后的第 i 个元素。这类运算是指针或地址算术运算中最简单的形式。

我们来看一个不完善的存储分配程序。

```c
第一个函数 alloc(n)返回一个指向 n 个连续字符存储单元的指针，alloc 函 数的调用者可利用该指针存储字符序列。
第二个函数 afree(p)释放已分配的存储空间，以 便以后重用。
之所以说这两个函数是“不完善的”，是因为对 afree 函数的调用次序必须与 调用 alloc 函数的次序相反。
alloc 与 afree 以栈的方式(即后进先出的列表) 进行存储空间的管理。
最容易的实现方法是让 alloc 函数对一个大字符数组 allocbuf 中的空间进行分配。
该 数组是 alloc 和 afree 两个函数私有的数组。
由于函数 alloc 和 afree 处理的对象是指 针而不是数组下标，因此，其它函数无需知道该数组的名字。
这样，可以在包含 alloc 和 afree 的源文件中将该数组声明为 static 类型，使得它对外不可见。
际实现时，该数组甚至可 以没有名字，它可以通过调用 malloc 函数或向操作系统申请一个指向无名存储块的指针获 得。
allocbuf 中的空间使用状况也是我们需要了解的信息。
我们使用指针 allocp 指向 allocbuf 中的下一个空闲单元。
当调用 alloc 申请 n 个字符的空间时，alloc 检查 allocbuf 数组中有没有足够的剩余空间。如果有足够的空闲空间，则 alloc 返回 allocp 的当前值(即空闲块的开始位置)，然后将 allocp 加 n 以使它指向下一个空闲区域。
如果空 闲空间不够，则 alloc 返回 0。
如果 p 在 allocbuf 的边界之内，则 afree(p)仅仅只是将 allocp 的值设置为 p。=
```

```c
#define AllOCSIZE 10000
static char allocbuf[ALLOCSIZE];
static char *allop = allocbuf;// =>static char* allocp = &allocbuf[0];


char *alloc(int n){
  if(allocbuf + ALLOCSIZE - allocp >= n) { //检查是否有足够的空闲空间
    allocp += n;
    return allocp - n;
  } else {   
    return 0;
  }
}
void afree(char *p) {
  if(p >= allocbuf && p< allocbuf + ALLOCSIZE)
    allocp = p;
}
```

一般情况下，同其他类型的变量一样，指针也可以初始化。通常，对指针有意义的初始 化值只能是 0 或者是表示地址的表达式，对后者来说，表达式所代表的地址必须是在此前已 定义的具有适当类型的数据的地址。例如，声明

​	static char* allocp = allocbuf;

将 allocp 定义为字符类型指针，并将它初始化为 allocbuf 的起始地址，该起始地址是程
序执行时的下一个空闲位置。上述语句也可以写成下列形式:
C 语言保证， 0 永远不是有效的数据地址，因此，返回值 0 可用来表示发生了异常事件。在本例中，返回值 0 表示没有足够的空闲空间可供分配。

指针和整数之间不能相互转换，但0是唯一的例外：常量0可以赋值给指针，指针也可以和常量0进行比较。程序中经常用符号常量NULL代替常量0，这样便于更清晰地说明常量0是指针的一个特殊值。符号常量NULL定义在标准头文件\<stddef.h\>中。

```
在某些情况下对指针可以进行比较运算。例如，如果指针p和q指向同一个数组的成员，那么它们之间就可以进行类似于==,!=,<,>=的比较关系运算。
任何指针与0进行相等或不等的比较运算都有意义。
指向不同数组的元素的指针之间的算术或比较运算没有定义。
```

```c
指针可以和整数进行相加或相减运算。
如 p+n 表示指针p当前指向的对象之后的第n个对象的地址。无论指针p指向的对象是何种类型。
指针的减法运算也是有意义的：如果p和q指向相同数组中的元素，且p<q，那么q-p+1就是位于p和q指向的元素之间的元素的数目。
/* strlen: return length of string s */
int strlen(char *s){
  char *p = s;
  while (*p != '\0') p++;
  return p - s; //返回了元素的数目
}
```

指针的算术运算具有一致性:如果处理的数据类型是比字符型占据更多存储空间的浮点 类型，并且 p 是一个指向浮点类型的指针，那么在执行 p++后，p 将指向下一个浮点数的地 址。因此，只需要将 alloc 和 afree 函数中所有的 char 类型替换为 float 类型，就可以 得到一个适用于浮点类型而非字符型的内存分配函数。所有的指针运算都会自动考虑它所指向的对象的长度。

有效的指针运算：

- 同类型指针之间的赋值运算；
- 指针同整数之间的加法或减法运算；
- 指向相同数组中元素的两个指针间的减法或比较运算；
- 将指针赋值为 0 或指针与 0 之间的比较运算。

其他所有形式的指针运算都是非法的。

#### 5.5 字符指针与函数

在字符串的内部表示中，字符数组以空字符'\0'结尾，所以，程序可以通过检查空字符找到
字符数组的结尾。字符串常量占据的存储单元数也因此比双引号内的字符数大 1。

printf("hello, world\n");
当类似于这样的一个字符串出现在程序中时，实际上是通过字符指针访问该字符串的。在上 述语句中，printf 接受的是一个指向字符数组第一个字符的指针。也就是说，字符串常量可 通过一个指向其第一个元素的指针访问。

除了作为函数参数外，字符串常量还有其它用法。假定指针 pmessage 的声明如下:
   char *pmessage;
那么，语句
pmessage ="now is the time";
将把一个指向该字符数组的指针赋值给 pmessage。该过程并没有进行字符串的复制，而只
是涉及到指针的操作。C 语言没有提供将整个字符串作为一个整体进行处理的运算符。

char amessage[] = "nw is the time"; /* 定义一个数组 */*

char \*pmessage = "now is the time"; /* 定义一个指针 */





